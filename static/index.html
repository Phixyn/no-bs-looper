<!DOCTYPE html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="No BS here only loops" />
    <meta name="keywords" content="adware,must,die" />
    <title>No Bullshit YouTube Looper</title>

    <link rel="stylesheet" href="css/foundation.min.css" />
    <link rel="stylesheet" href="css/app.css" />
  </head>

  <body>
    <h1>No Bullshit YouTube Looper</h1>

    <!-- The <iframe> (and video player) will replace this <div> tag -->
    <div id="player"></div>

    <!-- <input type="number" id="start-time" name="start-time" min="0" max="100" value="30"> -->
    <form>
      <label for="video-id">Video ID:</label>
      <input type="text" id="video-id" name="video-id" value="orxvTsPW10k"><br>
      <label for="start-time">Start time (seconds):</label>
      <input type="number" id="start-time" name="start-time" value="420"><br>
      <label for="end-time">End time (seconds):</label>
      <input type="number" id="end-time" name="end-time" value="727"><br>
      <input type="button" id="update-btn" name="update-btn" value="Update" onclick="updatePlayer()">
      <input type="reset" id="reset-btn" name="reset-btn" value="Reset"><br>
      <input type="button" id="toggle-vid-btn" name="toggle-vid-btn" value="Show/hide video" onclick="togglePlayer()">
    </form>

    <hr>
    <h3>Check these out</h3>
    <ul>
      <li>id: TtsQl_X3cbw</li>
      <li>start: 828</li>
      <li>end: 1155</li>
    </ul>

    <ul>
      <li>id: Uq-TffHkCcc</li>
      <li>start: 185 / 234</li>
      <li>end: 280 / 284</li>
    </ul>

    <script src="lib/jquery.js"></script>
    <script src="lib/what-input.js"></script>
    <script src="lib/foundation.min.js"></script>
    <script src="js/app.js"></script>

    <script>
      // TODO: move to app.js
      var videoId = document.getElementById("video-id").value;
      var startTime = parseInt(document.getElementById("start-time").value);
      var endTime = parseInt(document.getElementById("end-time").value);

      // Load the IFrame Player API code asynchronously
      var tag = document.createElement('script');

      tag.src = "https://www.youtube.com/iframe_api";
      var firstScriptTag = document.getElementsByTagName('script')[0];
      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

      var player;
      /**
       * Creates an <iframe> element (and YouTube player) after the API code
       * is downloaded.
       */
      function onYouTubeIframeAPIReady() {
        player = new YT.Player('player', {
          height: '390',
          width: '640',
          videoId: videoId,
          playerVars: {
            rel: 0,
            start: startTime,
            modestBranding: 1
          },
          events: {
            // 'onReady': onPlayerReady,
            'onStateChange': onPlayerStateChange
          }
        });
      }

      /**
       * Called by the API when the video player is ready.
       *
       * Reference: https://developers.google.com/youtube/iframe_api_reference#Events
       */
      // function onPlayerReady(event) {
        // event.target.playVideo();
        // Could use this, but if user seeks, endSeconds becomes invalidated
        // This is the same reason we don't have loop: 1 in our playerVars. Because
        // we have our own loop through the setInterval callback.
        // player.loadVideoById(
        //   {
        //     videoId: videoId,
        //     startSeconds: startTime,
        //     endSeconds: endTime
        //   }
        // );
      // }

      /**
       * Called by the API when the video player's state changes.
       *
       * Reference: https://developers.google.com/youtube/iframe_api_reference#Events
       */
      var timer = null;
      function onPlayerStateChange(event) {
        if (event.data == YT.PlayerState.PLAYING) {
          console.debug("Interval started.");
          timer = setInterval(eventCallback, 1000);
        }
        // TODO Check if this also affects things like player state == buffering,
        // and if so, maybe improve it.
        // Update: It does. Maybe do if (event.data == YT.PlayerState.PAUSED) ?
        else {
          if (timer != null) {
            console.debug("Interval cleared from onPlayerStateChange.");
            clearInterval(timer);
          }
        }
      }

      function eventCallback() {
        if (player.getCurrentTime() >= endTime) {
          player.seekTo(startTime, true);
        }
      }

      function updatePlayer() {
        console.debug("Updating player.");
        videoId = document.getElementById("video-id").value;
        startTime = parseInt(document.getElementById("start-time").value);
        endTime = parseInt(document.getElementById("end-time").value);

        // player.loadVideoById({videoId:String,
        //               startSeconds:Number,
        //               endSeconds:Number}):Void
        // endSeconds becomes invalid if user seeks, so it's pointless
        player.loadVideoById(
          {
            videoId: videoId,
            startSeconds: startTime
          }
        );
      }

      function togglePlayer() {
        console.debug("Toggling player visibility.");
        var playerDiv = document.getElementById("player");
        // TODO Get rid of first condition by assigning display: block to #player in CSS
        if (playerDiv.style.display === "" || playerDiv.style.display !== "none") {
          playerDiv.style.display = "none";
        } else {
          playerDiv.style.display = "block";
        }
      }
    </script>
  </body>
</html>